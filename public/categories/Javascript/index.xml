<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on Passing thoughts</title>
    <link>http://localhost:1313/categories/Javascript/</link>
    <description>Recent content in Javascript on Passing thoughts</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/Javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Convert HTML to Word</title>
      <link>http://localhost:1313/post/2024-04-23-HTML2Word/</link>
      <pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-04-23-HTML2Word/</guid>
      <description>Demo: download button here for laptop and desktop&#xA;Background&#xA;There is an issue with Barrister Admission Bundle I have wanted to solve for some time.&#xA;I wanted to make a website where users (pupil-barristers) could enter all required information at once, and then download a Word document.&#xA;The Word document would have all the information in the right place. But it also needs to be modifiable (as users probably have their own style preferences).</description>
    </item>
    <item>
      <title>Promise(), not promise</title>
      <link>http://localhost:1313/post/2024-04-03-Promise/</link>
      <pubDate>Wed, 03 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-04-03-Promise/</guid>
      <description>Quick test: what do these code snippets do?&#xA;const a = new Promise(function (a) { a }) const b = new Promise(function (b) { b(&amp;#34;success&amp;#34;) }) const c = new Promise(function (a, b) { b(&amp;#34;failure&amp;#34;) }) const d = Promise.resolve(&amp;#34;success&amp;#34;) const e = Promise.reject(&amp;#34;failure&amp;#34;) const f = new Promise(function (a, b) { a(&amp;#34;success&amp;#34;) b(&amp;#34;failure&amp;#34;) }) const g = new Promise(function (a, b) { b(&amp;#34;failure&amp;#34;) a(&amp;#34;success&amp;#34;) }) const h = new Promise(function (a, b) { throw new Error() }) const i = new Promise(function (a, b) { a() }) const j = new Promise(function (a, b) { b() }) const k = (number) =&amp;gt; { return new Promise(function (a, b) { a(number * 2) }) } Check by opening the console in your browser and test with e.</description>
    </item>
    <item>
      <title>object.property v. object[property]</title>
      <link>http://localhost:1313/post/2024-03-31-ObjectProperty/</link>
      <pubDate>Sun, 31 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-03-31-ObjectProperty/</guid>
      <description>I recently came across a situation where I was fetching information from a RESTful API. After some intermediate steps, I ended up with an array of objects, all of which have the same set of attribtues (e.g. including an id).&#xA;I wanted to have a way of printing a list of ids of the objects, e.g.&#xA;let attribute = id array.map(object =&amp;gt; &amp;lt;li&amp;gt; object.attribute &amp;lt;/li&amp;gt;) But this didn&amp;rsquo;t work.&#xA;It took me a while before I realised what I needed is instead:</description>
    </item>
    <item>
      <title>Why both capture and bubble events in Javascript dom?</title>
      <link>http://localhost:1313/post/2024-03-30-Capture/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-03-30-Capture/</guid>
      <description>Historical accident&#xA;The answer seems to be historical accident, not intentional design.&#xA;Back in the old days, Netscape advocated event capturing, while Microsoft promoted event bubbling. Both are part of the W3C Document Object Model Events standard (2000). &amp;ndash; Arun P Johny&#xA;If this is correct, the events of the browser wars in the 1990s are still shaping Javavscript into the 2020s!&#xA;In a way, this is unsurprising: backwards compatibility is important, which means features are often in a way that seem inelegant in hindsight.</description>
    </item>
    <item>
      <title>Anonymous functions have no reference in memory</title>
      <link>http://localhost:1313/post/2024-03-25-Anonymous/</link>
      <pubDate>Mon, 25 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-03-25-Anonymous/</guid>
      <description>I ran into a small bug today.&#xA;Following a tutorial, I added an anonymous function as the second argument to my window.addEventListener, i.e.&#xA;window.addEventListener(&amp;#34;popstate&amp;#34;, () =&amp;gt; console.log(&amp;#34;hello world&amp;#34;)) I then struggled to remove it with&#xA;window.removeEventListener(&amp;#34;popstate&amp;#34;, () =&amp;gt; console.log(&amp;#34;hello world&amp;#34;)) At first I tried to solve it with studying in detail the documentation for window.removeEventListener.&#xA;But soon I changed track: how can I find out what Event Listeners there are in my DOM (or in my window object)?</description>
    </item>
    <item>
      <title>In Array.sort()’s compareFn, the order of a and b doesn&#39;t matter</title>
      <link>http://localhost:1313/post/2024-03-24-CompareFn/</link>
      <pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-03-24-CompareFn/</guid>
      <description>MDN documentation on Array.prototype.sort() says of the the optional CompareFn,&#xA;A function that determines the order of the elements. The function is called with the following arguments:&#xA;a The first element for comparison. Will never be undefined.&#xA;b The second element for comparison. Will never be undefined.&#xA;It should return a number where:&#xA;A negative value indicates that a should come before b. A positive value indicates that a should come after b.</description>
    </item>
    <item>
      <title>Promises always return promises</title>
      <link>http://localhost:1313/post/2024-03-22-Promises/</link>
      <pubDate>Fri, 22 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2024-03-22-Promises/</guid>
      <description>I was trying to make a Promise object return an ordinary value (e.g. a number or a string), but failed.&#xA;And then I realised that Promises are never intended to return values other than Promises. Otherwise how can one “chain” then with .thens?&#xA;I can do what I wanted to do with this instead.&#xA;// declare a variable without initialising it let newValue // declare and initialise a promise const myPromise = new Promise((resolve, reject) =&amp;gt; { resolve(&amp;#34;foo&amp;#34;); }); // assign the value of the resolved promise to the variable myPromise.</description>
    </item>
  </channel>
</rss>
